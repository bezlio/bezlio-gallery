{
  "id": "91f8a80f-2549-47bc-acc3-899d5b71cd87",
  "name": "Company Directory",
  "template": "custom",
  "owner": "bellis@saberlogic.com",
  "shares": [],
  "vars": [
    {
      "name": "data",
      "value": "[]"
    },
    {
      "name": "dataIterator",
      "value": "[]"
    }
  ],
  "dataSubscriptions": [
    {
      "name": "directory",
      "connectionId": "a2d174a1-7c29-45fd-8f39-2d62f2727e8f",
      "dataSource": "brdb",
      "plugin": "ExcelPlugin",
      "method": "GetData",
      "args": {
        "FileName": "C:\\Program Files (x86)\\Bezlio Remote Data Broker\\Data\\company-directory.xlsx",
        "SheetName": "Directory",
        "FirstRowColumnNames": "Yes"
      },
      "data": null,
      "refreshInverval": 0,
      "lastRefresh": null
    }
  ],
  "markup": [
    "<label class=\"pull-right\" [hidden]=\"!bezl.vars.config.refreshing\">Loading... <i class=\"fa fa-spinner fa-spin\" style=\"font-size:24px\"></i></label>",
    "<button (click)=\"bezl.functions['refresh']()\" class=\"btn btn-md btn-primary pull-right\" *ngIf=\"!bezl.vars.config.refreshing\">Refresh</button>",
    "<div class=\"row\">",
    "<table style=\"width: 100%\" class=\"table table-striped\">",
    "    <tbody>",
    "        <!-- Start off by showing the top level column headers -->",
    "        <template ngFor let-s [ngForOf]=\"bezl.vars['config'].structure\" let-i=\"index\">",
    "            <tr *ngIf=\"i == 0\" style=\"background-color: white\">",
    "                <td  *ngIf=\"s.columns.length > 0 || s.type=='group'\">",
    "                    <div class=\"row\" style=\"padding: 0px\">",
    "                        ",
    "                        <div [ngClass]=\"'col-sm-' + c.columnSize\"",
    "                            *ngFor=\"let c of s.columns\"",
    "                            style=\"padding-left: 0px; padding-right: 0px;\">",
    "                            ",
    "                            <div style=\"width: 100%;text-align: center;\">",
    "                                <button type=\"button\" ",
    "                                        class=\"btn btn-default\"",
    "                                        style=\"background-color:white; width: 100%\"",
    "                                        (click)=\"bezl.functions['sort']( { section: s, column: c, sequence: 1, initial: false } )\">",
    "                                    <span>{{c.columnHeading}}</span>",
    "                                    <i class=\"fa fa-sort-numeric-asc pull-right\" aria-hidden=\"true\" ",
    "                                        *ngIf=\"c.sort == 'ascending' && (c.formatter.type == 'currency' || c.formatter.type == 'number' || c.formatter.type == 'percent')\"></i>",
    "                                    <i class=\"fa fa-sort-numeric-desc pull-right\" aria-hidden=\"true\" ",
    "                                        *ngIf=\"c.sort == 'descending' && (c.formatter.type == 'currency' || c.formatter.type == 'number' || c.formatter.type == 'percent')\"></i>",
    "                                    <i class=\"fa fa-sort-alpha-asc pull-right\" aria-hidden=\"true\" ",
    "                                        *ngIf=\"c.sort == 'ascending' && (c.formatter.type != 'currency' && c.formatter.type != 'number' && c.formatter.type != 'percent')\"></i>",
    "                                    <i class=\"fa fa-sort-alpha-desc pull-right\" aria-hidden=\"true\" ",
    "                                        *ngIf=\"c.sort == 'descending' && (c.formatter.type != 'currency' && c.formatter.type != 'number' && c.formatter.type != 'percent')\"></i>",
    "                                </button>",
    "                            </div>",
    "                        </div>",
    "                    </div> ",
    "                </td>",
    "            </tr>",
    "        </template>",
    "",
    "        <!-- Now begin looping through the entire data structure to construct our layout -->",
    "        <template ngFor let-d [ngForOf]=\"bezl.vars['dataIterator']\" let-i=\"index\">",
    "            <tr *ngIf=\"d.sequence == 1 || d.show\">",
    "                <td>",
    "                    <div class=\"row\" style=\"padding: 0px\"",
    "                        (click)=\"bezl.functions['selectRow'](d)\">",
    "                        <!-- Output the data in appropriate columns -->",
    "                        <div [ngClass]=\"'col-sm-' + c.columnSize\"",
    "                            *ngFor=\"let c of d.columns\"",
    "                            [ngStyle]=\"{'margin-left.px': ((c.columnPosition == 1) ? (d.sequence - 1) * 40 : 0)}\">",
    "                                <div *ngIf=\"d.type == 'group' && c.columnPosition == 1\" class=\"col-sm-1\" style=\"padding-right: 20px\">",
    "                                    <i class=\"fa fa-chevron-right\" aria-hidden=\"true\" *ngIf=\"!d.selected\"></i>",
    "                                    <i class=\"fa fa-chevron-down\" aria-hidden=\"true\" *ngIf=\"d.selected\"></i>",
    "                                </div>",
    "",
    "                                <div align=\"right\" *ngIf=\"c.formatter.type == 'currency'\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName]) | currency:c.formatter.currencyCode:c.formatter.symbolDisplay:(c.formatter.minIntegerDigits || '1') + ",
    "                                                            '.' + (c.formatter.minFractionDigits || '0') + ",
    "                                                            '-' + (c.formatter.maxFractionDigits || '1')}}",
    "                                </div>",
    "",
    "                                <div align=\"right\" *ngIf=\"c.formatter.type == 'percent'\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName]) | percent:(c.formatter.minIntegerDigits || '1') + ",
    "                                                            '.' + (c.formatter.minFractionDigits || '0') + ",
    "                                                            '-' + (c.formatter.maxFractionDigits || '1')}}",
    "                                </div>",
    "",
    "                                <div *ngIf=\"c.formatter.type == 'date'\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName]) | date:c.formatter.format}}",
    "                                </div>",
    "",
    "                                <div align=\"right\" *ngIf=\"c.formatter.type == 'number'\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName]) | number:(c.formatter.minIntegerDigits || '1') + ",
    "                                                            '.' + (c.formatter.minFractionDigits || '0') + ",
    "                                                            '-' + (c.formatter.maxFractionDigits || '1')}}",
    "                                </div>",
    "",
    "                                <div *ngIf=\"c.formatter.type == ''\">",
    "\t\t\t\t\t\t\t\t\t<div *ngIf=\"c.columnName == 'PhoneNumber'\">",
    "                                      <a href=\"tel:{{(d.data[c.columnId] || d.data[c.columnName])}}\">{{(d.data[c.columnId] || d.data[c.columnName])}}</a>",
    "                                  \t</div>",
    "                                  ",
    "\t\t\t\t\t\t\t\t\t<div *ngIf=\"c.columnName == 'E-Mail'\">",
    "                                      <a href=\"mailto:{{(d.data[c.columnId] || d.data[c.columnName])}}\">{{(d.data[c.columnId] || d.data[c.columnName])}}</a>",
    "                                  \t</div>",
    "\t",
    "                                  \t<div *ngIf=\"c.columnName != 'PhoneNumber' && c.columnName != 'E-Mail'\">",
    "                                    \t{{(d.data[c.columnId] || d.data[c.columnName])}}",
    "                                 \t</div>",
    "                                </div>",
    "                        </div>",
    "                    </div> ",
    "",
    "                </td>",
    "            </tr>",
    "",
    "            <!-- Add column headings if this is a grouping -->",
    "            <template ngFor let-s [ngForOf]=\"bezl.vars['config'].structure\">",
    "                <tr *ngIf=\"s.sequence == d.sequence + 1 && d.selected\" style=\"background-color: white\">",
    "                    <td  *ngIf=\"s.columns.length > 0\">",
    "                        <div class=\"row\" style=\"padding: 0px\">                                                                    ",
    "                            <div [ngClass]=\"'col-sm-' + c.columnSize\"",
    "                                *ngFor=\"let c of s.columns\"",
    "                                style=\"padding-left: 0px; padding-right: 0px;\"",
    "                                [ngStyle]=\"{'margin-left.px': ((c.columnPosition == 1) ? (s.sequence - 1) * 40 : 0)}\">",
    "                                ",
    "                                <div style=\"width: 100%;text-align: center;\">",
    "                                    <button type=\"button\" ",
    "                                            class=\"btn btn-default\"",
    "                                            style=\"background-color:white; width: 100%\"",
    "                                            (click)=\"bezl.functions['sort']( { section: s, column: c, sequence: s.sequence, initial: false } )\">",
    "                                        <span>{{c.columnHeading}}</span>",
    "                                        <i class=\"fa fa-sort-numeric-asc pull-right\" aria-hidden=\"true\" ",
    "                                            *ngIf=\"c.sort == 'ascending' && (c.formatter.type == 'currency' || c.formatter.type == 'number' || c.formatter.type == 'percent')\"></i>",
    "                                        <i class=\"fa fa-sort-numeric-desc pull-right\" aria-hidden=\"true\" ",
    "                                            *ngIf=\"c.sort == 'descending' && (c.formatter.type == 'currency' || c.formatter.type == 'number' || c.formatter.type == 'percent')\"></i>",
    "                                        <i class=\"fa fa-sort-alpha-asc pull-right\" aria-hidden=\"true\" ",
    "                                            *ngIf=\"c.sort == 'ascending' && (c.formatter.type != 'currency' && c.formatter.type != 'number' && c.formatter.type != 'percent')\"></i>",
    "                                        <i class=\"fa fa-sort-alpha-desc pull-right\" aria-hidden=\"true\" ",
    "                                            *ngIf=\"c.sort == 'descending' && (c.formatter.type != 'currency' && c.formatter.type != 'number' && c.formatter.type != 'percent')\"></i>",
    "                                    </button>",
    "                                </div>",
    "                            </div>",
    "                        </div> ",
    "                    </td>",
    "                </tr>",
    "            </template>",
    "        </template>",
    "    </tbody>",
    "</table>",
    "</div>"
  ],
  "functions": [
    {
      "method": "ngOnInit",
      "code": "bezl.vars.config = {};\nbezl.vars.config.refreshing = true;\n\nfunction Refresh (bezl) {\n  bezl.vars.config.refreshing = true;\n  bezl.dataService.process('directory');\n}\n\nfunction RegenerateOutput (bezl) {\n  eval(bezl.vars.config.outputFormula);\n\n  // This function will be used to \"flatten\" out the values when multiple levels of grouping were\n  // used\n  var rollupValues = function(obj, returnValues) {\n    obj.forEach(o => {\n      if (o.values) {\n        rollupValues(o.values, returnValues);\n      } else {\n        returnValues.push(o);\n      }\n    });\n  }\n\n  // Now add in each of the summarized fields at each group level\n  // obj:           This is the actual property we are evaluating.  It starts off as the entire\n  //                data object and then crawls through each values sub object.\n  // sequence:      This helps us to marry up which piece of the data object we are looking\n  //                at as compared to the structure object.  This is incremented by 1 for each\n  //                level deeper we go.\n  // config:        A reference to the config object.  Does not change in the process,\n  //                simply needed as a reference since the recursive function is out of scope.\n  // parentUid:     A reference to the parent object UID.\n  // dataIterator:  A reference to the dataIterator object we are populating.\n  var processValues = function(obj, sequence, config, parentUid, dataIterator) {\n    var s = config.structure.find(s => s.sequence == sequence);\n\n    if (obj.length > 0 && obj[0].values && obj[0].values.length > 0)\n    {\n      obj.forEach(o => {\n        o.sequence = sequence;\n        o.uid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n          var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n          return v.toString(16);\n        });\n        var nextIsGroup = config.structure.find(s => s.sequence == sequence + 1 && s.type == 'group');\n\n        var values = [];\n        if (nextIsGroup) {\n          rollupValues(o.values, values);\n        } else {\n          values = o.values;\n        }\n\n        dataIterator.push({ sequence: sequence, data: o, columns: s.columns, type: s.type, selected: false, parentUid: parentUid, uid: o.uid });\n\n        s.columns.forEach(col => {\n          switch (col.summaryOperation) {\n            case 'first':\n              o[col.columnId] = values[0][col.columnName];\n              break;\n            case 'last':\n              o[col.columnId] = values[o.values.length - 1][col.columnName];\n              break;\n            case 'count':\n              o[col.columnId] = values.length;\n              break;\n            case 'min':\n              o[col.columnId] = d3.min(values, function (d) { return d[col.columnName]; });\n              break;\n            case 'max':\n              o[col.columnId] = d3.max(values, function (d) { return d[col.columnName]; });\n              break;\n            case 'extent':\n              o[col.columnId] = d3.extent(values, function (d) { return d[col.columnName]; });\n              break;\n            case 'sum':\n              o[col.columnId] = d3.sum(values, function (d) { return d[col.columnName]; });\n              break;\n            case 'mean':\n              o[col.columnId] = d3.mean(values, function (d) { return d[col.columnName]; });\n              break;\n            case 'median':\n              o[col.columnId] = d3.median(values, function (d) { return d[col.columnName]; });\n              break;\n            case 'variance':\n              o[col.columnId] = d3.variance(values, function (d) { return d[col.columnName]; });\n              break;\n            case 'deviation':\n              o[col.columnId] = d3.deviation(values, function (d) { return d[col.columnName]; });\n              break;\n            default:\n              o[col.columnId] = values[0][col.columnName];\n              break;\n          }\n        });\n\n        processValues(o.values, sequence + 1, config, o.uid, dataIterator);\n      });\n    } else {\n      obj.forEach(o => {\n        o.sequence = sequence;\n        dataIterator.push({ sequence: sequence, data: o, columns: s.columns, type: s.type, selected: false, parentUid: parentUid });\n      });\n    }\n  };\n\n  // Use a temp object for processing the data that we point back to\n  // when done to trigger Angular change detection\n  var tempData = bezl.vars.data;\n  bezl.vars.dataIterator = [];\n  processValues(tempData, 1, bezl.vars.config, '', bezl.vars.dataIterator);\n  bezl.vars.data = tempData;\n\n  // Apply sorts\n  bezl.vars.config.structure.forEach(s => {\n    s.columns.forEach(c => {\n      if (c.sort != '') {\n        Sort(bezl, { section: s, column: c, sequence: s.sequence, initial: true });\n      }\n    });\n  });\n}\n\nfunction Sort(bezl, parm) {\n  var tempData = bezl.vars.dataIterator;\n  var section = parm.section;\n  var column = parm.column;\n  var sequence = parm.sequence;\n  var initial = parm.initial;\n\n\n  // Set the column sort direction unless this is the initial sorting\n  if (!initial) {\n    if (!column.sort && (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent')) {\n      column.sort = 'descending';\n    } else if (!column.sort || column.sort == 'descending') {\n      column.sort = 'ascending';\n    } else if (column.sort == 'ascending') {\n      column.sort = 'descending';\n    }\n  }\n\n  // Also zap any previous sort indicators\n  section.columns.forEach(col => {\n    if (col != column) {\n      col.sort = '';\n    }\n  });\n\n  // First index all of the entries\n  for (var i = 0; i < tempData.length; i++) {\n    tempData[i].index = i;\n  }\n\n  // Next sort by sequence so we can clump together same-level data\n  tempData.sort(function(a, b) { return a.sequence - b.sequence; });\n\n  // Now locate the stop and start positions of the sequence level we are sorting\n  var start = tempData.findIndex(r => r.sequence == sequence);\n  var end = tempData.slice(start, tempData.length).findIndex(r => r.sequence != sequence);\n  if (end == -1) {\n    end = tempData.length;\n  }\n\n  // Store the unsorted elements before and after our sequence level\n  var pre = tempData.slice(0, start);\n  pre.sort(function(a, b) { return a.index - b.index; });\n  var post = tempData.slice(start, tempData.length).slice(end, tempData.length);\n  post.sort(function(a, b) { return a.index - b.index; });\n\n  // Now sort the sequence level\n  var sorted = tempData.slice(start, end).sort(function(a, b) {\n    if (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent') {\n      // Push the nulls to the bottom\n      if ((a.data[column.columnId] || a.data[column.columnName]) == null) {\n        return 1;\n      } else if ((b.data[column.columnId] || b.data[column.columnName]) == null) {\n        return -1;\n      }\n\n      if (column.sort == 'descending') {\n        var A = (a.data[column.columnId] || a.data[column.columnName]) != null ? (a.data[column.columnId] || a.data[column.columnName]) : Number.MAX_VALUE;\n        var B = (b.data[column.columnId] || b.data[column.columnName]) != null ? (b.data[column.columnId] || b.data[column.columnName]) : Number.MAX_VALUE;\n        return B - A;\n      } else {\n        var A = (a.data[column.columnId] || a.data[column.columnName]) != null ? (a.data[column.columnId] || a.data[column.columnName]) : Number.MAX_VALUE;\n        var B = (b.data[column.columnId] || b.data[column.columnName]) != null ? (b.data[column.columnId] || b.data[column.columnName]) : Number.MAX_VALUE;\n        return A - B;\n      }\n    } else {\n      var A = (a.data[column.columnId] || a.data[column.columnName] || '').toString().toUpperCase(); // ignore upper and lowercase\n      var B = (b.data[column.columnId] || b.data[column.columnName] || '').toString().toUpperCase(); // ignore upper and lowercase\n\n      if (column.sort == 'ascending') {\n        if (A < B) {\n          return -1;\n        }\n        if (A > B) {\n          return 1;\n        }\n      } else {\n        if (A > B) {\n          return -1;\n        }\n        if (A < B) {\n          return 1;\n        }\n      }\n\n      // names must be equal\n      return 0;\n    }\n  });\n\n  // Reconstruct the array.  If the sequence is greater than 1 then reverse\n  // the sorted object so we can put them back under the parent last to first\n  if (sequence == 1) {\n    tempData = pre.concat(sorted).concat(post);\n  } else {\n    tempData = pre.concat(sorted.reverse()).concat(post);\n  }\n\n  var moveElement = function (array, old_index, new_index) {\n    if (new_index >= array.length) {\n      var k = new_index - array.length;\n      while ((k--) + 1) {\n        array.push(undefined);\n      }\n    }\n    array.splice(new_index, 0, array.splice(old_index, 1)[0]);\n  };\n\n  // Now put the child records back inline with parents\n  tempData.forEach(row => {\n    if (row.sequence >= sequence) {\n      var parent = tempData.find(t => t.uid == row.parentUid);\n      if (parent) {\n        moveElement(tempData, tempData.indexOf(row), tempData.indexOf(parent) + 1);\n      }\n    }\n  });\n\n  bezl.vars['dataIterator'] = tempData;\n}\n\nfunction SelectRow(bezl, parm) {\n  var row = parm;\n  var selected = !row.selected;\n  row.selected = selected;\n\n  var keepGoing = true;\n  var i = bezl.vars['dataIterator'].indexOf(row) + 1;\n  while (keepGoing) {\n    if (bezl.vars['dataIterator'][i]) {\n\n      // If the row is a child, flip the show flag based on whether\n      // the parent row is selected\n      if (bezl.vars['dataIterator'][i].sequence == row.sequence + 1) {\n        bezl.vars['dataIterator'][i].show = selected;\n\n        // If the parent is unselected, also unselect this child row\n        if (!selected) {\n          bezl.vars['dataIterator'][i].selected = selected;\n        }\n\n        // For deeper children, unselect and hide only when the parent flips to\n        // selected\n      } else if (bezl.vars['dataIterator'][i].sequence >= row.sequence + 1 && !selected) {\n        bezl.vars['dataIterator'][i].selected = selected;\n        bezl.vars['dataIterator'][i].show = selected;\n      } else if (bezl.vars['dataIterator'][i].sequence <= row.sequence + 1) {\n        keepGoing = false;\n      }\n      i++;\n    } else {\n      keepGoing = false;\n    }\n  }\n}\n\nbezl.functions['setConfig']();\n\nbezl.vars.functions = {};\nbezl.vars.functions.refresh = Refresh;\nbezl.vars.functions.regenerateOutput = RegenerateOutput;\nbezl.vars.functions.sort = Sort;\nbezl.vars.functions.selectRow = SelectRow;\n\n",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts",
        "d3"
      ],
      "compiled": "bezl.vars.config = {};\r\nbezl.vars.config.refreshing = true;\r\nfunction Refresh(bezl) {\r\n    bezl.vars.config.refreshing = true;\r\n    bezl.dataService.process('directory');\r\n}\r\nfunction RegenerateOutput(bezl) {\r\n    eval(bezl.vars.config.outputFormula);\r\n    // This function will be used to \"flatten\" out the values when multiple levels of grouping were\r\n    // used\r\n    var rollupValues = function (obj, returnValues) {\r\n        obj.forEach(function (o) {\r\n            if (o.values) {\r\n                rollupValues(o.values, returnValues);\r\n            }\r\n            else {\r\n                returnValues.push(o);\r\n            }\r\n        });\r\n    };\r\n    // Now add in each of the summarized fields at each group level\r\n    // obj:           This is the actual property we are evaluating.  It starts off as the entire\r\n    //                data object and then crawls through each values sub object.\r\n    // sequence:      This helps us to marry up which piece of the data object we are looking\r\n    //                at as compared to the structure object.  This is incremented by 1 for each\r\n    //                level deeper we go.\r\n    // config:        A reference to the config object.  Does not change in the process,\r\n    //                simply needed as a reference since the recursive function is out of scope.\r\n    // parentUid:     A reference to the parent object UID.\r\n    // dataIterator:  A reference to the dataIterator object we are populating.\r\n    var processValues = function (obj, sequence, config, parentUid, dataIterator) {\r\n        var s = config.structure.find(function (s) { return s.sequence == sequence; });\r\n        if (obj.length > 0 && obj[0].values && obj[0].values.length > 0) {\r\n            obj.forEach(function (o) {\r\n                o.sequence = sequence;\r\n                o.uid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n                    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n                    return v.toString(16);\r\n                });\r\n                var nextIsGroup = config.structure.find(function (s) { return s.sequence == sequence + 1 && s.type == 'group'; });\r\n                var values = [];\r\n                if (nextIsGroup) {\r\n                    rollupValues(o.values, values);\r\n                }\r\n                else {\r\n                    values = o.values;\r\n                }\r\n                dataIterator.push({ sequence: sequence, data: o, columns: s.columns, type: s.type, selected: false, parentUid: parentUid, uid: o.uid });\r\n                s.columns.forEach(function (col) {\r\n                    switch (col.summaryOperation) {\r\n                        case 'first':\r\n                            o[col.columnId] = values[0][col.columnName];\r\n                            break;\r\n                        case 'last':\r\n                            o[col.columnId] = values[o.values.length - 1][col.columnName];\r\n                            break;\r\n                        case 'count':\r\n                            o[col.columnId] = values.length;\r\n                            break;\r\n                        case 'min':\r\n                            o[col.columnId] = d3.min(values, function (d) {\r\n                                return d[col.columnName];\r\n                            });\r\n                            break;\r\n                        case 'max':\r\n                            o[col.columnId] = d3.max(values, function (d) {\r\n                                return d[col.columnName];\r\n                            });\r\n                            break;\r\n                        case 'extent':\r\n                            o[col.columnId] = d3.extent(values, function (d) {\r\n                                return d[col.columnName];\r\n                            });\r\n                            break;\r\n                        case 'sum':\r\n                            o[col.columnId] = d3.sum(values, function (d) {\r\n                                return d[col.columnName];\r\n                            });\r\n                            break;\r\n                        case 'mean':\r\n                            o[col.columnId] = d3.mean(values, function (d) {\r\n                                return d[col.columnName];\r\n                            });\r\n                            break;\r\n                        case 'median':\r\n                            o[col.columnId] = d3.median(values, function (d) {\r\n                                return d[col.columnName];\r\n                            });\r\n                            break;\r\n                        case 'variance':\r\n                            o[col.columnId] = d3.variance(values, function (d) {\r\n                                return d[col.columnName];\r\n                            });\r\n                            break;\r\n                        case 'deviation':\r\n                            o[col.columnId] = d3.deviation(values, function (d) {\r\n                                return d[col.columnName];\r\n                            });\r\n                            break;\r\n                        default:\r\n                            o[col.columnId] = values[0][col.columnName];\r\n                            break;\r\n                    }\r\n                });\r\n                processValues(o.values, sequence + 1, config, o.uid, dataIterator);\r\n            });\r\n        }\r\n        else {\r\n            obj.forEach(function (o) {\r\n                o.sequence = sequence;\r\n                dataIterator.push({ sequence: sequence, data: o, columns: s.columns, type: s.type, selected: false, parentUid: parentUid });\r\n            });\r\n        }\r\n    };\r\n    // Use a temp object for processing the data that we point back to\r\n    // when done to trigger Angular change detection\r\n    var tempData = bezl.vars.data;\r\n    bezl.vars.dataIterator = [];\r\n    processValues(tempData, 1, bezl.vars.config, '', bezl.vars.dataIterator);\r\n    bezl.vars.data = tempData;\r\n    // Apply sorts\r\n    bezl.vars.config.structure.forEach(function (s) {\r\n        s.columns.forEach(function (c) {\r\n            if (c.sort != '') {\r\n                Sort(bezl, { section: s, column: c, sequence: s.sequence, initial: true });\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction Sort(bezl, parm) {\r\n    var tempData = bezl.vars.dataIterator;\r\n    var section = parm.section;\r\n    var column = parm.column;\r\n    var sequence = parm.sequence;\r\n    var initial = parm.initial;\r\n    // Set the column sort direction unless this is the initial sorting\r\n    if (!initial) {\r\n        if (!column.sort && (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent')) {\r\n            column.sort = 'descending';\r\n        }\r\n        else if (!column.sort || column.sort == 'descending') {\r\n            column.sort = 'ascending';\r\n        }\r\n        else if (column.sort == 'ascending') {\r\n            column.sort = 'descending';\r\n        }\r\n    }\r\n    // Also zap any previous sort indicators\r\n    section.columns.forEach(function (col) {\r\n        if (col != column) {\r\n            col.sort = '';\r\n        }\r\n    });\r\n    for (var i = 0; i < tempData.length; i++) {\r\n        tempData[i].index = i;\r\n    }\r\n    // Next sort by sequence so we can clump together same-level data\r\n    tempData.sort(function (a, b) {\r\n        return a.sequence - b.sequence;\r\n    });\r\n    // Now locate the stop and start positions of the sequence level we are sorting\r\n    var start = tempData.findIndex(function (r) { return r.sequence == sequence; });\r\n    var end = tempData.slice(start, tempData.length).findIndex(function (r) { return r.sequence != sequence; });\r\n    if (end == -1) {\r\n        end = tempData.length;\r\n    }\r\n    // Store the unsorted elements before and after our sequence level\r\n    var pre = tempData.slice(0, start);\r\n    pre.sort(function (a, b) {\r\n        return a.index - b.index;\r\n    });\r\n    var post = tempData.slice(start, tempData.length).slice(end, tempData.length);\r\n    post.sort(function (a, b) {\r\n        return a.index - b.index;\r\n    });\r\n    // Now sort the sequence level\r\n    var sorted = tempData.slice(start, end).sort(function (a, b) {\r\n        if (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent') {\r\n            // Push the nulls to the bottom\r\n            if ((a.data[column.columnId] || a.data[column.columnName]) == null) {\r\n                return 1;\r\n            }\r\n            else if ((b.data[column.columnId] || b.data[column.columnName]) == null) {\r\n                return -1;\r\n            }\r\n            if (column.sort == 'descending') {\r\n                var A = (a.data[column.columnId] || a.data[column.columnName]) != null ? (a.data[column.columnId] || a.data[column.columnName]) : Number.MAX_VALUE;\r\n                var B = (b.data[column.columnId] || b.data[column.columnName]) != null ? (b.data[column.columnId] || b.data[column.columnName]) : Number.MAX_VALUE;\r\n                return B - A;\r\n            }\r\n            else {\r\n                var A = (a.data[column.columnId] || a.data[column.columnName]) != null ? (a.data[column.columnId] || a.data[column.columnName]) : Number.MAX_VALUE;\r\n                var B = (b.data[column.columnId] || b.data[column.columnName]) != null ? (b.data[column.columnId] || b.data[column.columnName]) : Number.MAX_VALUE;\r\n                return A - B;\r\n            }\r\n        }\r\n        else {\r\n            var A = (a.data[column.columnId] || a.data[column.columnName] || '').toString().toUpperCase(); // ignore upper and lowercase\r\n            var B = (b.data[column.columnId] || b.data[column.columnName] || '').toString().toUpperCase(); // ignore upper and lowercase\r\n            if (column.sort == 'ascending') {\r\n                if (A < B) {\r\n                    return -1;\r\n                }\r\n                if (A > B) {\r\n                    return 1;\r\n                }\r\n            }\r\n            else {\r\n                if (A > B) {\r\n                    return -1;\r\n                }\r\n                if (A < B) {\r\n                    return 1;\r\n                }\r\n            }\r\n            // names must be equal\r\n            return 0;\r\n        }\r\n    });\r\n    // Reconstruct the array.  If the sequence is greater than 1 then reverse\r\n    // the sorted object so we can put them back under the parent last to first\r\n    if (sequence == 1) {\r\n        tempData = pre.concat(sorted).concat(post);\r\n    }\r\n    else {\r\n        tempData = pre.concat(sorted.reverse()).concat(post);\r\n    }\r\n    var moveElement = function (array, old_index, new_index) {\r\n        if (new_index >= array.length) {\r\n            var k = new_index - array.length;\r\n            while ((k--) + 1) {\r\n                array.push(undefined);\r\n            }\r\n        }\r\n        array.splice(new_index, 0, array.splice(old_index, 1)[0]);\r\n    };\r\n    // Now put the child records back inline with parents\r\n    tempData.forEach(function (row) {\r\n        if (row.sequence >= sequence) {\r\n            var parent = tempData.find(function (t) { return t.uid == row.parentUid; });\r\n            if (parent) {\r\n                moveElement(tempData, tempData.indexOf(row), tempData.indexOf(parent) + 1);\r\n            }\r\n        }\r\n    });\r\n    bezl.vars['dataIterator'] = tempData;\r\n}\r\nfunction SelectRow(bezl, parm) {\r\n    var row = parm;\r\n    var selected = !row.selected;\r\n    row.selected = selected;\r\n    var keepGoing = true;\r\n    var i = bezl.vars['dataIterator'].indexOf(row) + 1;\r\n    while (keepGoing) {\r\n        if (bezl.vars['dataIterator'][i]) {\r\n            // If the row is a child, flip the show flag based on whether\r\n            // the parent row is selected\r\n            if (bezl.vars['dataIterator'][i].sequence == row.sequence + 1) {\r\n                bezl.vars['dataIterator'][i].show = selected;\r\n                // If the parent is unselected, also unselect this child row\r\n                if (!selected) {\r\n                    bezl.vars['dataIterator'][i].selected = selected;\r\n                }\r\n            }\r\n            else if (bezl.vars['dataIterator'][i].sequence >= row.sequence + 1 && !selected) {\r\n                bezl.vars['dataIterator'][i].selected = selected;\r\n                bezl.vars['dataIterator'][i].show = selected;\r\n            }\r\n            else if (bezl.vars['dataIterator'][i].sequence <= row.sequence + 1) {\r\n                keepGoing = false;\r\n            }\r\n            i++;\r\n        }\r\n        else {\r\n            keepGoing = false;\r\n        }\r\n    }\r\n}\r\nbezl.functions['setConfig']();\r\nbezl.vars.functions = {};\r\nbezl.vars.functions.refresh = Refresh;\r\nbezl.vars.functions.regenerateOutput = RegenerateOutput;\r\nbezl.vars.functions.sort = Sort;\r\nbezl.vars.functions.selectRow = SelectRow;\r\n"
    },
    {
      "method": "onDataChange",
      "code": "bezl.data = dataResp;\n\nif (bezl.data.directory != null && bezl.data.directory.length > 0) {\n  bezl.functions['regenerateOutput'](bezl)\n  bezl.vars.config.refreshing = false;\n}",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": "bezl.data = dataResp;\r\nif (bezl.data.directory != null && bezl.data.directory.length > 0) {\r\n    bezl.functions['regenerateOutput'](bezl);\r\n    bezl.vars.config.refreshing = false;\r\n}\r\n"
    },
    {
      "method": "refresh",
      "code": "bezl.vars.functions.refresh();",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": "bezl.vars.functions.refresh();\r\n"
    },
    {
      "method": "regenerateOutput",
      "code": "bezl.vars.functions.regenerateOutput(bezl)\n",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts",
        "d3"
      ],
      "compiled": "bezl.vars.functions.regenerateOutput(bezl);\r\n"
    },
    {
      "method": "sort",
      "code": "bezl.vars.functions.sort(bezl, parm);",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": "bezl.vars.functions.sort(bezl, parm);\r\n"
    },
    {
      "method": "selectRow",
      "code": "bezl.vars.functions.selectRow(bezl, parm)\n",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": "bezl.vars.functions.selectRow(bezl, parm);\r\n"
    },
    {
      "method": "setConfig",
      "code": "bezl.vars.config = {\n\t\"description\": \"Advanced Grid\",\n\t\"icon\": \"fa-table\",\n\t\"ref\": \"1ea17cbe-5c14-6c2a-640b\",\n\t\"showAll\": false,\n\t\"outputFormula\": \"bezl.vars.data = d3.nest().key(function(d) { return d.Location; }).key(function(d) { return d.Department; }).entries(bezl.data.directory);\",\n\t\"structure\": [\n\t\t{\n\t\t\t\"sequence\": 1,\n\t\t\t\"type\": \"group\",\n\t\t\t\"caption\": \"Location Grouping:\",\n\t\t\t\"groupField\": \"Location\",\n\t\t\t\"summaryOperation\": \"first\",\n\t\t\t\"columns\": [\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"f833dc57-a02f-e4b4-9a5b\",\n\t\t\t\t\t\"columnName\": \"Location\",\n\t\t\t\t\t\"columnHeading\": \"Location\",\n\t\t\t\t\t\"columnSize\": 4,\n\t\t\t\t\t\"columnPosition\": 1,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"ascending\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"c7a8e537-e648-ac67-92f2\",\n\t\t\t\t\t\"columnName\": \"FirstName\",\n\t\t\t\t\t\"columnHeading\": \"Employees\",\n\t\t\t\t\t\"columnSize\": 2,\n\t\t\t\t\t\"columnPosition\": 2,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"\",\n\t\t\t\t\t\"summaryOperation\": \"count\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"sequence\": 2,\n\t\t\t\"type\": \"group\",\n\t\t\t\"caption\": \"Department Grouping:\",\n\t\t\t\"groupField\": \"Department\",\n\t\t\t\"summaryOperation\": \"first\",\n\t\t\t\"columns\": [\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"2c1b5366-7c5a-a1e7-1a4e\",\n\t\t\t\t\t\"columnName\": \"Department\",\n\t\t\t\t\t\"columnHeading\": \"Department\",\n\t\t\t\t\t\"columnSize\": 4,\n\t\t\t\t\t\"columnPosition\": 1,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"ascending\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"afa058fe-d184-fe23-c4fa\",\n\t\t\t\t\t\"columnName\": \"FirstName\",\n\t\t\t\t\t\"columnHeading\": \"Employees\",\n\t\t\t\t\t\"columnSize\": 2,\n\t\t\t\t\t\"columnPosition\": 2,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"\",\n\t\t\t\t\t\"summaryOperation\": \"count\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"sequence\": 3,\n\t\t\t\"type\": \"detail\",\n\t\t\t\"caption\": \"Details:\",\n\t\t\t\"groupField\": \"\",\n\t\t\t\"summaryOperation\": \"\",\n\t\t\t\"columns\": [\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"245bd417-eb91-45f6-7484\",\n\t\t\t\t\t\"columnName\": \"LastName\",\n\t\t\t\t\t\"columnHeading\": \"Last Name\",\n\t\t\t\t\t\"columnSize\": 2,\n\t\t\t\t\t\"columnPosition\": 1,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"ascending\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"a4b35294-ff83-1d3b-0aeb\",\n\t\t\t\t\t\"columnName\": \"FirstName\",\n\t\t\t\t\t\"columnHeading\": \"First Name\",\n\t\t\t\t\t\"columnSize\": 2,\n\t\t\t\t\t\"columnPosition\": 2,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"b1932440-9be1-5ae2-dfc7\",\n\t\t\t\t\t\"columnName\": \"Title\",\n\t\t\t\t\t\"columnHeading\": \"Title\",\n\t\t\t\t\t\"columnSize\": 2,\n\t\t\t\t\t\"columnPosition\": 3,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"1a287679-d349-7de9-a731\",\n\t\t\t\t\t\"columnName\": \"PhoneNumber\",\n\t\t\t\t\t\"columnHeading\": \"Phone #\",\n\t\t\t\t\t\"columnSize\": 2,\n\t\t\t\t\t\"columnPosition\": 4,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"columnId\": \"75ff7a20-5dc4-9ad0-fab5\",\n\t\t\t\t\t\"columnName\": \"E-Mail\",\n\t\t\t\t\t\"columnHeading\": \"E-Mail\",\n\t\t\t\t\t\"columnSize\": 3,\n\t\t\t\t\t\"columnPosition\": 5,\n\t\t\t\t\t\"formatter\": {\n\t\t\t\t\t\t\"type\": \"\",\n\t\t\t\t\t\t\"obj\": {\n\t\t\t\t\t\t\t\"parameters\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sort\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n};",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": "bezl.vars.config = {\r\n    \"description\": \"Advanced Grid\",\r\n    \"icon\": \"fa-table\",\r\n    \"ref\": \"1ea17cbe-5c14-6c2a-640b\",\r\n    \"showAll\": false,\r\n    \"outputFormula\": \"bezl.vars.data = d3.nest().key(function(d) { return d.Location; }).key(function(d) { return d.Department; }).entries(bezl.data.directory);\",\r\n    \"structure\": [\r\n        {\r\n            \"sequence\": 1,\r\n            \"type\": \"group\",\r\n            \"caption\": \"Location Grouping:\",\r\n            \"groupField\": \"Location\",\r\n            \"summaryOperation\": \"first\",\r\n            \"columns\": [\r\n                {\r\n                    \"columnId\": \"f833dc57-a02f-e4b4-9a5b\",\r\n                    \"columnName\": \"Location\",\r\n                    \"columnHeading\": \"Location\",\r\n                    \"columnSize\": 4,\r\n                    \"columnPosition\": 1,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"ascending\"\r\n                },\r\n                {\r\n                    \"columnId\": \"c7a8e537-e648-ac67-92f2\",\r\n                    \"columnName\": \"FirstName\",\r\n                    \"columnHeading\": \"Employees\",\r\n                    \"columnSize\": 2,\r\n                    \"columnPosition\": 2,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"\",\r\n                    \"summaryOperation\": \"count\"\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            \"sequence\": 2,\r\n            \"type\": \"group\",\r\n            \"caption\": \"Department Grouping:\",\r\n            \"groupField\": \"Department\",\r\n            \"summaryOperation\": \"first\",\r\n            \"columns\": [\r\n                {\r\n                    \"columnId\": \"2c1b5366-7c5a-a1e7-1a4e\",\r\n                    \"columnName\": \"Department\",\r\n                    \"columnHeading\": \"Department\",\r\n                    \"columnSize\": 4,\r\n                    \"columnPosition\": 1,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"ascending\"\r\n                },\r\n                {\r\n                    \"columnId\": \"afa058fe-d184-fe23-c4fa\",\r\n                    \"columnName\": \"FirstName\",\r\n                    \"columnHeading\": \"Employees\",\r\n                    \"columnSize\": 2,\r\n                    \"columnPosition\": 2,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"\",\r\n                    \"summaryOperation\": \"count\"\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            \"sequence\": 3,\r\n            \"type\": \"detail\",\r\n            \"caption\": \"Details:\",\r\n            \"groupField\": \"\",\r\n            \"summaryOperation\": \"\",\r\n            \"columns\": [\r\n                {\r\n                    \"columnId\": \"245bd417-eb91-45f6-7484\",\r\n                    \"columnName\": \"LastName\",\r\n                    \"columnHeading\": \"Last Name\",\r\n                    \"columnSize\": 2,\r\n                    \"columnPosition\": 1,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"ascending\"\r\n                },\r\n                {\r\n                    \"columnId\": \"a4b35294-ff83-1d3b-0aeb\",\r\n                    \"columnName\": \"FirstName\",\r\n                    \"columnHeading\": \"First Name\",\r\n                    \"columnSize\": 2,\r\n                    \"columnPosition\": 2,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"\"\r\n                },\r\n                {\r\n                    \"columnId\": \"b1932440-9be1-5ae2-dfc7\",\r\n                    \"columnName\": \"Title\",\r\n                    \"columnHeading\": \"Title\",\r\n                    \"columnSize\": 2,\r\n                    \"columnPosition\": 3,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"\"\r\n                },\r\n                {\r\n                    \"columnId\": \"1a287679-d349-7de9-a731\",\r\n                    \"columnName\": \"PhoneNumber\",\r\n                    \"columnHeading\": \"Phone #\",\r\n                    \"columnSize\": 2,\r\n                    \"columnPosition\": 4,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"\"\r\n                },\r\n                {\r\n                    \"columnId\": \"75ff7a20-5dc4-9ad0-fab5\",\r\n                    \"columnName\": \"E-Mail\",\r\n                    \"columnHeading\": \"E-Mail\",\r\n                    \"columnSize\": 3,\r\n                    \"columnPosition\": 5,\r\n                    \"formatter\": {\r\n                        \"type\": \"\",\r\n                        \"obj\": {\r\n                            \"parameters\": []\r\n                        }\r\n                    },\r\n                    \"sort\": \"\"\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n};\r\n"
    },
    {
      "method": "ngAfterViewInit",
      "code": "",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": ""
    }
  ],
  "data": ""
}